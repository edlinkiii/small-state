export default class SmallState{static #instance;#state={};#initial={};#locked=[];#subscriptions={};#check={typeOf:(x)=>{if(x===undefined){return "undefined"}if(x===null){return "null"}return x.constructor.name.toLowerCase()},isString:(str)=>this.#check.typeOf(str)==="string",isArray:(arr)=>this.#check.typeOf(arr)==="array",isFunction:(func)=>this.#check.typeOf(func)==="function",propertyExists:(property)=>Object.hasOwn(this.#state,property),propertyIsLocked:(property)=>this.#locked.includes(property)};#error={propertyAlredyExists:(property)=>`Specified state property [${ property }] already exists.`,propertyDoesNotExist:(property)=>`Specified state property [${ property }] does not exist.`,propertyIsLocked:(property)=>`Specified state property [${ property }] is not alterable.`,functionIsRequired:(property)=>`A function is required to add a subscriber for property (${ property })`};constructor(){if(SmallState.#instance){return SmallState.#instance}SmallState.#instance=this}error(errorMessage){console.error(`SmallStateError: ${ errorMessage }`)}add(property,value=null,lock=false){if(this.#check.propertyExists(property)){this.error(this.#error.propertyAlredyExists(property));return null}this.#initial[property]=value;this.#state[property]=undefined;this.#subscriptions[property]=[];this.reset(property);if(lock){this.lock(property)}return this}has(property){const hasProperty=this.#check.propertyExists(property);return hasProperty}get(property){if(!this.#check.propertyExists(property)){throw new Error(this.#error.propertyDoesNotExist(property))}return this.#state[property]}set(property,value){if(!this.#check.propertyExists(property)){this.error(this.#error.propertyDoesNotExist(property));return null}if(this.#check.propertyIsLocked(property)){this.error(this.#error.propertyIsLocked(property));return null}this.#state[property]=value;this.emit(property);return this}reset(property){if(!this.#check.propertyExists(property)){this.error(this.#error.propertyDoesNotExist(property));return null}if(this.#check.propertyIsLocked(property)){this.error(this.#error.propertyIsLocked(property));return null}return this.set(property,this.#initial[property])}remove(property){if(!this.#check.propertyExists(property)){this.error(this.#error.propertyDoesNotExist(property));return null}if(this.#check.propertyIsLocked(property)){this.error(this.#error.propertyIsLocked(property));return null}delete this.#state[property];delete this.#initial[property];delete this.#subscriptions[property];return this}lock(property){this.#locked=[...new Set([...this.#locked,property])];return this}unlock(property){this.#locked=this.#locked.filter((locked)=>locked!==property);return this}subscribe(property,callback){if(!this.#check.isFunction(callback)){this.error(this.#error.functionIsRequired((property)));return}if(this.#check.isArray(property)){(property).forEach((prop)=>this.subscribe(prop,callback));return}if(this.#check.isString(property)){if(!this.#check.propertyExists(property)){this.error(this.#error.propertyDoesNotExist(property));return}this.#subscriptions[(property)].push(callback)}}unsubscribe(property,callback=null){if(this.#check.isArray(property)){(property).forEach((prop)=>this.unsubscribe(prop,callback));return}else if(this.#check.isString(property)){if(!this.#check.propertyExists(property)){this.error(this.#error.propertyDoesNotExist(property));return}if(callback===null){this.#subscriptions[(property)]=null}else if(!this.#check.isFunction(callback)){const filterFunction=(cb)=>cb!==callback;this.#subscriptions[(property)].filter(filterFunction)}}}emit(property){const subscriptions=this.#subscriptions[property];if(!subscriptions?.length){return}const value=this.get(property);subscriptions.forEach((callback)=>callback(value))}}