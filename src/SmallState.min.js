export class SmallState{static#t;#r={};#s={};#e=[];#i={};#o={isString:t=>"string"==typeof t,isArray:t=>Array.isArray(t),isFunction:t=>"function"==typeof t,propertyExists:t=>Object.hasOwn(this.#r,t),propertyIsLocked:t=>this.#e.includes(t)};#h={propertyAlredyExists:t=>`Specified state property [${t}] already exists.`,propertyDoesNotExist:t=>`Specified state property [${t}] does not exist.`,propertyIsLocked:t=>`Specified state property [${t}] is not alterable.`,functionIsRequired:t=>`A function is required to add a subscriber for property (${t})`};constructor(){if(SmallState.#t)return SmallState.#t;SmallState.#t=this}add(t,r=null,s=!1){if(this.#o.propertyExists(t))throw new Error(this.#h.propertyAlredyExists(t));return this.#s[t]=r,this.#r[t]=void 0,this.#i[t]=[],this.reset(t),s&&this.lock(t),this}get(t){if(!this.#o.propertyExists(t))throw new Error(this.#h.propertyDoesNotExist(t));return this.#r[t]}set(t,r){if(!this.#o.propertyExists(t))throw new Error(this.#h.propertyDoesNotExist(t));if(this.#o.propertyIsLocked(t))throw new Error(this.#h.propertyIsLocked(t));return this.#r[t]=r,this.emit(t),this}reset(t){if(!this.#o.propertyExists(t))throw new Error(this.#h.propertyDoesNotExist(t));if(this.#o.propertyIsLocked(t))throw new Error(this.#h.propertyIsLocked(t));return this.set(t,this.#s[t])}remove(t){if(!this.#o.propertyExists(t))throw new Error(this.#h.propertyDoesNotExist(t));if(this.#o.propertyIsLocked(t))throw new Error(this.#h.propertyIsLocked(t));return delete this.#r[t],delete this.#s[t],delete this.#i[t],this}lock(t){this.#e=[...new Set([...this.#e,t])]}unlock(t){this.#e=this.#e.filter((r=>r!==t))}subscribe(t,r=null){if(this.#o.isString(t)&&!this.#o.propertyExists(t))throw new Error(this.#h.propertyDoesNotExist(t));if(!this.#o.isFunction(r))throw new Error(this.#h.functionIsRequired(t));const s=this.#i[t];this.#o.isArray(t)?t.forEach((t=>this.subscribe(t,r))):s.push(r)}unsubscribe(t,r=null){let s=this.#i[t];this.#o.isArray(t)?t.forEach((t=>this.unsubscribe(t,r))):s=null===r?[]:s.filter((t=>t!==r)),this.#i[t]=s}emit(t){const r=this.#i[t];if(!r?.length)return;const s=this.get(t);r.forEach((t=>t(s)))}}